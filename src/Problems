28. Implement strStr()
Implement strStr().
Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

350.Intersection of Two Arrays II - Easy 
Given two arrays, write a function to compute their intersection.
Example:
Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].
Note:
Each element in the result should appear as many times as it shows in both arrays.
The result can be in any order.
Follow up:
What if the given array is already sorted? How would you optimize your algorithm?
What if nums1's size is small compared to nums2's size? Which algorithm is better?
What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?

83.Remove Duplicates from Sorted List   
Given a sorted linked list, delete all duplicates such that each element appear only once.
For example,
Given 1->1->2, return 1->2.
Given 1->1->2->3->3, return 1->2->3.

Sort List
Sort a linked list in O(n log n) time using constant space complexity.
			time			space
quick sort  O(nlogn)    O(1)
merge sort  O(nlogn)    O(n)  但在linked list中为O(1)
heap sort   O(nlogn)    O(1)
solution1: merge sort, merge时要注意将剩余的加上

88.Merge Sorted Array   
Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.
Note:
You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.

141. Linked List Cycle I - Easy
Given a linked list, determine if it has a cycle in it.
Follow up:
Can you solve it without using extra space?

142.Linked List Cycle II - Easy
Given a linked list, return the node where the cycle begins. If there is no cycle, return null.
Note: Do not modify the linked list.
Follow up:
Can you solve it without using extra space?

206.Reverse Linked List - Easy
Reverse a singly linked list.

Reverse Nodes in k-Group
Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.
If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.
You may not alter the values in the nodes, only nodes itself may be changed.
Only constant memory is allowed.
Example
Given this linked list: 1->2->3->4->5
For k = 2, you should return: 2->1->4->3->5
For k = 3, you should return: 3->2->1->4->5
思路：在普通reverse linked list的基础上（见图）
Note：辅助function的参数和返回值
不满k时情况的处理
重连接部分是难点

Copy List with Random Pointer

273.Delete Node in a Linked List - Easy
Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.
Supposed the linked list is 1 -> 2 -> 3 -> 4 and you are given the third node with value 3, the linked list should become 1 -> 2 -> 4 after calling your function.
 
203.Remove Linked List Elements - Easy
Remove all elements from a linked list of integers that have value val.
Example
Given: 1 --> 2 --> 6 --> 3 --> 4 --> 5 --> 6, val = 6
Return: 1 --> 2 --> 3 --> 4 --> 5

160. Intersection of Two Linked Lists - Easy
Write a program to find the node at which the intersection of two singly linked lists begins.
For example, the following two linked lists:
A:          a1 → a2
                   ↘
                     c1 → c2 → c3
                   ↗            
B:     b1 → b2 → b3
begin to intersect at node c1.
Notes:
If the two linked lists have no intersection at all, return null.
The linked lists must retain their original structure after the function returns.
You may assume there are no cycles anywhere in the entire linked structure.
Your code should preferably run in O(n) time and use only O(1) memory.

234. Palindrome Linked List - Easy
Given a singly linked list, determine if it is a palindrome. Follow up: Could you do it in O(n) time and O(1) space?

############# TREE #################
144.Binary Tree Preorder Traversal - Medium   
Given a binary tree, return the preorder traversal of its nodes' values.
For example:
Given binary tree {1,#,2,3},return [1,2,3].

145.Binary Tree Postorder Traversal- Hard
Given a binary tree, return the postorder traversal of its nodes' values.
For example:
Given binary tree {1,#,2,3},return [3,2,1].
Note: Recursive solution is trivial, could you do it iteratively?

173.Binary Search Tree Iterator - Medium  
Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.
Calling next() will return the next smallest number in the BST.
Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.
 
102. Binary Tree Level Order Traversal Add to List
Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).
For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its level order traversal as:
[
  [3],
  [9,20],
  [15,7]
]
Note: 用BFS(Queue结构)，注意的是一层的node要全遍历一下，取出val，并把他们的children抽出，
为了做到分层，应该引入一个Queue size的变量，用来跟踪一行一行的node


226. Invert Binary Tree
Invert a binary tree.

     4
   /   \
  2     7
 / \   / \
1   3 6   9
to
     4
   /   \
  7     2
 / \   / \
9   6 3   1
Note: 这题用recursive还是比较简单，但要注意将左枝先保存起来
 
108. Convert Sorted Array to Binary Search Tree
Given an array where elements are sorted in ascending order, convert it to a height balanced BST.
思路：recursively取中间的数作为node，(mid, start, end)，注意一下start < end
 
101.Symmetric Tree
Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).
For example, this binary tree [1,2,2,3,4,4,3] is symmetric:
    1
   / \
  2   2
 / \ / \
3  4 4  3
But the following [1,2,2,null,3,null,3] is not:
    1
   / \
  2   2
   \   \
   3    3
 
257. Binary Tree Paths
Given a binary tree, return all root-to-leaf paths.
For example, given the following binary tree:
   1
 /   \
2     3
 \
  5
All root-to-leaf paths are:
["1->2->5", "1->3"]

111. Minimum Depth of Binary Tree
Given a binary tree, find its minimum depth.
The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.
Note:单边null时，min不是null的那边，而是非null一边的结果

543.Diameter of Binary Tree
Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.
Example:
Given a binary tree 
          1
         / \
        2   3
       / \     
      4   5    
Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3]。
思路:
solution1: left+right,遍历 
solution2(不可行): 2bfs not working， 主要因为TreeNode是单向的，第二次bfs的tree形不成

104.Maximum Depth of Binary Tree

235.Lowest Common Ancestor of a Binary Search Tree
Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.
According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”
        _______6______
       /              \
    ___2__          ___8__
   /      \        /      \
   0      _4       7       9
         /  \
         3   5
For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.

236.Lowest Common Ancestor of a Binary Tree
Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.
According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”
        _______3______
       /              \
    ___5__          ___1__
   /      \        /      \
   6      _2       0       8
         /  \
         7   4
For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.
解法：借用ListNode的LC160的想法，先构建parent信息，对应得存入HashMap,然后将p的各级parent提取出存在HashSet
里，然后逐个提取q的parent信息，和p的parent集比较，找出一样的

116.Populating Next Right Pointers in Each Node
Given a binary tree
    struct TreeLinkNode {
      TreeLinkNode *left;
      TreeLinkNode *right;
      TreeLinkNode *next;
    }
Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.
Initially, all next pointers are set to NULL.
Note:
You may only use constant extra space.
You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).

501.Find Mode in Binary Search Tree
Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST.
Assume a BST is defined as follows:
The left subtree of a node contains only nodes with keys less than or equal to the node's key.
The right subtree of a node contains only nodes with keys greater than or equal to the node's key.
Both the left and right subtrees must also be binary search trees.
For example:
Given BST [1,null,2,2],
   1
    \
     2
    /
   2
return [2].

109.Convert Sorted List to Binary Search Tree
Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.
思路：类似于array to BST,为了找中点，用快慢指针

94. Binary Tree Inorder Traversal
Given a binary tree, return the inorder traversal of its nodes' values.
For example:
Given binary tree [1,null,2,3],
   1
    \
     2
    /
   3
return [1,3,2].

113. Path Sum II
Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.
For example:
Given the below binary tree and sum = 22,
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
return
[
   [5,4,11,2],
   [5,8,4,5]
]

98.Validate Binary Search Tree
Given a binary tree, determine if it is a valid binary search tree (BST).
Assume a BST is defined as follows:
The left subtree of a node contains only nodes with keys less than the node's key.
The right subtree of a node contains only nodes with keys greater than the node's key.
Both the left and right subtrees must also be binary search trees.
Example 1:
    2
   / \
  1   3
Binary tree [2,1,3], return true.
Example 2:
    1
   / \
  2   3
Binary tree [1,2,3], return false.

199.Binary Tree Right Side View
Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.
For example:
Given the following binary tree,
   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---
You should return [1, 3, 4].
思路一：借鉴LC102的想法
思路二：recursive，每一层最右边的node被选出，通过recursive总是选右边的，每增加一层，input一个right node,
但有时候中间比外边deep，也需要extract出来，所以先right，再left,left支的depth他超过已有array size时可以加入元素
Note：先右再左，用array size作为判断标准，加一个depth变量（与array size进行比较）

TopView of Binary Tree
思路一： 借鉴rightSideView的想法，分别找出leftview,rightview, 为了避免侧面看得到但上面
看不到,又引入了一个叫column的list，将已有的column记录其中，要是前面出现的该column，就不增加
这个方法不是很好，建solution2
思路二： BFS , 增加一个变量指示node所在column，将改变量打包进queue
 
297. Serialize and Deserialize Binary Tree
Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.
Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.
For example, you may serialize the following tree
    1
   / \
  2   3
     / \
    4   5
 as "[1,2,3,null,null,4,5]", just the same as how LeetCode OJ serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.
Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.
思路：serialize-BFS，deserialize-for loop,roots用queue保持

GraphValidTree
Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.
Notice
You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges. 
Example
Given n = 5 and edges = [[0, 1], [0, 2], [0, 3], [1, 4]], return true.
Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]], return false.
思路：BFS + graph adjacent list表示法 HashMap<Integer, HashSet<Integer>>;
 
133. Clone Graph
Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.
OJ's undirected graph serialization:
Nodes are labeled uniquely.
We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.
As an example, consider the serialized graph {0,1,2#1,2#2,2}.
The graph has a total of three nodes, and therefore contains three parts as separated by #.
First node is labeled as 0. Connect node 0 to both nodes 1 and 2.
Second node is labeled as 1. Connect node 1 to node 2.
Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.
Visually, the graph looks like the following:
       1
      / \
     /   \
    0 --- 2
         / \
         \_/
思路：先用bfs得到点集，克隆顶点(old->new map)，通过old的neighbor克隆new 的neighbor

Topological Sorting
Given an directed graph, a topological order of the graph nodes is defined as follow:
For each directed edge A -> B in graph, A must before B in the order list.
The first node in the order can be any node in the graph with no nodes direct to it.
Find any topological order for the given graph.
思路：HashMap记录各点的indegree， BFS，依次移除indegree为0 的点

Search Graph Nodes
Given a undirected graph, a node and a target, return the nearest node to given node which value of it is target, return NULL if you can't find.
There is a mapping store the nodes' values in the given parameters.
2------3  5
 \     |  | 
  \    |  |
   \   |  |
    \  |  |
      1 --4
Give a node 1, target is 50
there a hash named values which is [3,4,10,50,50], represent:
Value of node 1 is 3
Value of node 2 is 4
Value of node 3 is 10
Value of node 4 is 50
Value of node 5 is 50
Return node 4
思路： BFS

Zombie In Matrix
Given a 2D grid, each cell is either a wall 2, a zombie 1 or people 0 (the number zero, one, two).Zombies can turn the nearest people(up/down/left/right) into zombies every day, but can not through wall. How long will it take to turn all people into zombies? Return -1 if can not turn all people into zombies.
Example
Given a matrix:
0 1 2 0 0
1 0 0 2 1
0 1 0 0 0
return 2
思路： BFS，将Zombie作为start，放入queue，层级遍历，每天一层，将Zombie周边的人变成Zombie，直到people为0
Note：0，1，2用常理PEOPLE等定义

200. Number of Islands
Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.
Example 1:
11110
11010
11000
00000
Answer: 1
思路：BFS，每找到一个1，将其旁边一层的1变为0，依次下去，把这个island都变成0，再找下一个island

274. H-Index - Medium   
Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index.
According to the definition of h-index on Wikipedia: "A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each."
For example, given citations = [3, 0, 6, 1, 5], which means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, his h-index is 3.
Note: If there are several possible values for h, the maximum one is taken as the h-index.



211. Add and Search Word - Data structure design - Medium 
Design a data structure that supports the following two operations:
void addWord(word)
bool search(word)
search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.
For example:
addWord("bad")
addWord("dad")
addWord("mad")
search("pad") -> false
search("bad") -> true
search(".ad") -> true
search("b..") -> true

189. Rotate Array
Rotate an array of n elements to the right by k steps.
For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].
Note:
Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.

338. Counting Bits
Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array.
Example:
For num = 5 you should return [0,1,1,2,1,2].
Follow up:
It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?
Space complexity should be O(n).
Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.
思路1：dynamic programming,从左往右，f(n) = f(n/2) + n%2;

121.Best Time to Buy and Sell Stock
Say you have an array for which the ith element is the price of a given stock on day i.
If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.
Example 1:
Input: [7, 1, 5, 3, 6, 4]
Output: 5
max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)
Example 2:
Input: [7, 6, 4, 3, 1]
Output: 0
In this case, no transaction is done, i.e. max profit = 0.

############# DP #################
139. Word Break
Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words.
For example, given
s = "leetcode",
dict = ["leet", "code"].
Return true because "leetcode" can be segmented as "leet code".
UPDATE (2017/1/4):
The wordDict parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.
思路：建一个boolean array，bool[i] 为TRUE时s.substring(0,i)可以分解
解法一：对于bool[i],loop through dict,如果前面部分已有bool为TRUE，后面部分正好是一个单词，则为TRUE
解法二：当dict为set时可以用contains的方法，对于bool[i],loop through dict,如果有 bool[j] == true && s.substring(i,j)在dict set中

140. Word Break2
Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. You may assume the dictionary does not contain duplicate words.
Return all such possible sentences.
For example, given
s = "catsanddog",
dict = ["cat", "cats", "and", "sand", "dog"].
A solution is ["cats and dog", "cat sand dog"].
UPDATE (2017/1/4):
The wordDict parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.
思路：Top down DP,loop through dict(因为不是set，不能用contains),将string最后部分和每个词典中单词匹配，匹配上后
将string以该店切分，总结果为前面string对应的List结果的每个string加上最后该单词。至于前面string的结果就可以通过recursive求得
Note:1.Base case,string不断切分下去总会有len==0的时候，将“”作为其返回结果
     2.用HashMap保存中间结果<String, List<String>>，否则时间复杂度太大
     3.不用考虑是否可分割的问题，不不能分割，会自动返回空list

WordBreakIII:基于LC139，LC140， 要求改为：当字符串可分解时，返回任意一种分解结果
思路：基于LC139基础上，从DP构建返回结果，故复杂度为O(n^2)
还有单纯recursive的方法，但复杂度为O(2^n)

96.Unique Binary Search Trees
Given n, how many structurally unique BST's (binary search trees) that store values 1...n?
For example,
Given n = 3, there are a total of 5 unique BST's.
   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
思路：本题结果等于分别以1,2,..n为root的BST数量之和，而怎么计算比如以i为root的BST数量之和呢？可以这么考虑
i的左枝有多少种可能，右支有多少种可能，因为左支和右支是没有交集的，所以总共可能数是左边可能情况数乘以右边
用数学式来表示，比如G(n)表示1...n个数组成的unique BST个数，F(i,n)表示1...n个数组成的BST中，以i为root
的BST数，则F(i,n) = G(i-1)*G(n-i), G(i-1)好理解，因为iroot左边是n个数中比i小的数即1..i-1,他们总共
G(i-1)种，而剩下的i+1,i+2,..n可组成的BST数是等同于1,2,..n-i组成的BST数(因为个数一样，这是主要trick)


95. Unique Binary Search Trees II
Given an integer n, generate all structurally unique BST's (binary search trees) that store values 1...n.
For example,
Given n = 3, your program should return all 5 unique BST's shown below.

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
思路：这题不是DP只是单纯recursive，输入为start，end，每个i作为root，左边是（start，i-1)，右边是（i+1,end）
####################### DFS ######################

320. Generalized Abbreviation
Write a function to generate the generalized abbreviations of a word.
Example: Given word = "word", return the following list (order does not matter):
["word", "1ord", "w1rd", "wo1d", "wor1", "2rd", "w2d", "wo2", >"1o1d", "1or1", "w1r1", "1o2", "2r1", "3d", "w3", "4"]
思路：DFS/backtracking
解法一：分为3部分，字符开头(0-len)+数字段(1-end)+subproblem(要注意单拎出来第一个字符，可以防止联系两个数字连在一起)
解法二：每个pos分为保留不保留两种处理，然后pos+1，处理到结尾，输出结果

78. Subsets I
Given a set of distinct integers, nums, return all possible subsets.
Note: The solution set must not contain duplicate subsets.
解法一：recursive法，n个元素的结果为n-1个元素的结果加上((n-1)个元素结果+第n个元素)
解法二：DFS

90. Subsets II
Given a collection of integers that might contain duplicates, nums, return all possible subsets.
Note: The solution set must not contain duplicate subsets.
思路：主要要注意去重，只取相同数中第一个作为下一个

46. Permutations
Given a collection of distinct numbers, return all possible permutations.
For example,
[1,2,3] have the following permutations:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
思路： 类似subset，但要注意加curr时加个判断，而且要return，curr add时也要加判断
draft:
[1,2]
dfs([],[],[1,2])
    i = 0
        curr = [1]
        dfs([],[1],[1,2])
            i =0
                \\ dfs([],[1],[1,2])

            i=1
                curr = [1,2]
                dfs([],[1,2],[1,2])
                    result = [[1,2]]
                curr = [1]

        curr = []
    i=1
        curr = [2]

47. Permutations II
Given a collection of numbers that might contain duplicates, return all possible unique permutations.
For example,
[1,1,2] have the following unique permutations:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]

39. Combination Sum
Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.
The same repeated number may be chosen from C unlimited number of times.
Note:
All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
For example, given candidate set [2, 3, 6, 7] and target 7, 
A solution set is: 
[
  [7],
  [2, 2, 3]
] 
思路：DFS，类似suset,不同点在于1）元素可以重复（选数的时候，下一个还是从i开始，而不是i+1）
2）有target限制 3）一开始input可能就有重复（所以需要提前sort并remove duplicates）

40. Combination Sum II
Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.
Each number in C may only be used once in the combination.
Note:
All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8, 
A solution set is: 
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]


*******************************************************
**               Topic 2: Binary Search              **
*******************************************************
Classical Binary Search
Find any position of a target number in a sorted array. Return -1 if target does not exist.
Example
Given [1, 2, 2, 4, 5, 5].
For target = 2, return 1 or 2.
For target = 5, return 4 or 5.
For target = 6, return -1.

First Position of Target 
For a given sorted array (ascending order) and a target number, find the first index of this number in O(log n) time complexity.
If the target number does not exist in the array, return -1.

Last Position of Target
Find the last position of a target number in a sorted array. Return -1 if target does not exist.

Maximum Number in Mountain Sequence
Given a mountain sequence of n integers which increase firstly and then decrease, find the mountain top.
Example
Given nums = [1, 2, 4, 8, 6, 3] return 8
Given nums = [10, 9, 8, 7], return 10
思路：模板+比较mid和mid+1

*******************************************************
**               Topic 8: Data Structure             **
*******************************************************
Rehashing
The size of the hash table is not determinate at the very beginning. If the total size of keys is too large (e.g. size >= capacity / 10), we should double the size of the hash table and rehash every keys. Say you have a hash table looks like below:
size=3, capacity=4
[null, 21, 14, null]
       ↓    ↓
       9   null
       ↓
      null。
The hash function is:
int hashcode(int key, int capacity) {
    return key % capacity;
}
here we have three numbers, 9, 14 and 21, where 21 and 9 share the same position as they all have the same hashcode 1 (21 % 4 = 9 % 4 = 1). We store them in the hash table by linked list.
rehashing this hash table, double the capacity, you will get:
size=3, capacity=8
index:   0    1    2    3     4    5    6   7
hash : [null, 9, null, null, null, 21, 14, null]
Given the original hash table, return the new hash table after rehashing .

LRU Cache
Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.
get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.
Follow up:
Could you do both operations in O(1) time complexity?
Example:
LRUCache cache = new LRUCache( 2 /* capacity */ );
cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // returns 1
cache.put(3, 3);    // evicts key 2
cache.get(2);       // returns -1 (not found)
cache.put(4, 4);    // evicts key 1
cache.get(1);       // returns -1 (not found)
cache.get(3);       // returns 3
cache.get(4);       // returns 4

Ugly Number II
Ugly number is a number that only have factors 2, 3 and 5.
Design an algorithm to find the nth ugly number. The first 10 ugly numbers are 1, 2, 3, 4, 5, 6, 8, 9, 10, 12...
思路：
Heap(Priority queue) + HashSet
每次取出(retrieve and remove)heap中最小值，分别乘以2，3，5，如果heap中不存在，就加入heap
错误：
每次取出heap头，然后分别乘以2，3，5，选取最小的重新加入queue，比如heap头为3，加入3*2，但3被拿掉了，其实3*3也要加入heap的，但无法实现了
Note:
数据类型，int不够，要用Long(Long.valueOf() , number.intValue())
Queue和hashSet同时add
对数字1的处理，不放入队列中

Top k Largest Numbers II
Implement a data structure, provide two interfaces:
add(number). Add a new number in the data structure.
topk(). Return the top k largest numbers in this data structure. k is given when we create the data structure.
思路：
用minheap,如果超出k个，poll出最小元素
Note:
private variables,在开头申明，在构造函数中初始化
取出queue中元素，用iterator(Iterator<Integer> it = q.iterator(); it.hasNext(), (Integer) it.next())
Collections.sort()实现list的逆序排序( Collections.sort(result, Collections.reverseOrder());)

Merge K sorted Lists
Merge k sorted linked lists and return it as one sorted list.
Analyze and describe its complexity.
思路：
法一： divide and conquer
法二： heap